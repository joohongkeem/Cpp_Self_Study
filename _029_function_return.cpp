
/*
	* 함수는 네가지 다른 방법으로 T형의 값을 리턴할 수 있다.

		1) T f();			: 함수 선언에서와 같이 평범하고 상투적인 값으로
		2) const T f();		: 함수 선언에서와 같이 상수 값으로
		3) T& f();			: 함수 선언에서와 같이 참조로
		4) const T& f();	: 함수 선언에서와 같이 const 참조로

	- int나 char같은 단순한 형을 리턴할 때, const를 사용하는 것은 아무 의미가 없다.
	  따라서 프로그래머는 일반적으로 단순형을 리턴할 때 const를 사용하지 않는다.
	  만약 단순한 형을 리턴할 때 l-value로 리턴하고 싶다면 할당문의 좌측에 참조에 의해 리턴한다.
	  그러지 않을 경우에는 평범하고 단순한 값으로 리턴한다.

	- 만약, 리턴되는 값이 l-value로 사용되기를 원한다면 리턴형에 &를 사용하여 참조로 리턴해야 한다.
	  지역 변수(또는 생명주기가 짧은 객체)를 참조에 의해 리턴할 경우(const가 있건 없던)는 문제를 야기하므로
	  피해야 한다.

	- 클래스형의 경우는 단순하지 않다.
	  클래스형의 경우, const T와 const T&로 리턴되는 경우는 유사하다.
	  두 가지 경우 모두 다음과 같이 mutator 함수에 의해 리턴되는 객체를 직접적으로 변경할 수 없다.
		ex) f().mutator();

	- 리턴되는 값은 할당 연산자를 이용하여 다른 변수에 복사할 수 있고, 다른 변수도 mutator 함수를 갖는다.
	  만약 const T와 const T& 중에 어떤 것을 사용할지 결정하지 못햇다면 const T를 사용하라.

	[★꿀팁★]

	- 만약 public 멤버 함수가 private 멤버를 리턴하고자 한다면, 리턴형에 const를 사용해야 한다.
	  ( 이 규칙의 한 가지 예외는, string형을 리턴할 때 const 값에 의해서가 아니라 일반적이 값으로 리턴해야 한다는 것이다.
	    string형이 클래스형일지라도 스트링은 int나 char처럼 단순형으로 취급되게 때문이다)

		1) 함수 선언에서와 같이 단순한 값으로 리턴되는 경우 -> T f();
		 - l-value로 사용될 수 없고, f().mutator() 에서 직접적으로 값이 변경될 수 있다. 복사 생성자를 호출한다.

		2) 함수 선언에서와 같이 const 값으로 리턴되는 경우 -> const T f();
		 - 이 경우는 리턴되는 값이 f().mutator()에서 직접적으로 변경될 수 없다는 점을 제외하고는 위와 같다.

		3) 함수 선언에서와 같이 참조로 리턴되는 경우 -> T& f();
		 - l-value로 사용할 수 있고, 리턴되는 값이 f().mutator() 에서 직접적으로 변경될 수 있다. 복사 생성자를 호출하지 않는다.

		4) 함수 선언에서와 같이 const 참조로 리턴되는 경우 -> const T& f();
		 - l-value로 사용할 수 있고, 리턴되는 값이 f().mutator() 에서 직접적으로 변경될 수 없다. 복사 생성자를 호출하지 않는다.

*/