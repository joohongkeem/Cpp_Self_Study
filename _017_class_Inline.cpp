#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
using namespace std;

/*
	* 인라인 함수

	- 클래스 정의 안에서 멤버 함수를 완전하게 정의할 수 있다.
	  이러한 정의를 인라인 함수 정의(inline function definitions) 라고 한다.
		-> 일반적으로 함수 정의가 매우 짧을 때 사용한다.★★★

	- 인라인 함수는 이미 봐 왔던 멤버 함수에 대한 또 다른 표현법, 그 이상의 의미를 갖는다
		-> 컴파일러는 인라인 함수를 특별하게 취급한다.
		   인라인 함수 선언 코드는 이 함수가 호출될 때마다 그 곳에 삽입되므로,
		   함수 호출로 인한 오버헤드가 줄어든다.★★
		   But, 클래스의 인터페이스와 구현이 섞이게 되므로 캡슐화의 원칙에 맞지 않는다.
		        또한, 많은 컴파일러에서 인라인 함수는 자신이 정의된 파일에서만 호출될 수 있게하고 있다.
		   또, 함수정의가 긴 경우에는 인라인으로 정의하는 것이 비효율적이다.

	- 어떤 함수도 인라인 함수로 정의될 수 있다.(사용여부를 스스로 결정해야 한다.)
		-> 함수 선언과 함수 정의 앞에 inline이란 키워드를 두기만 하면 된다!!
	
	(특징)
	- 인라인 함수를 사용하려면 함수 선언 앞에 inline이라는 키워드를 붙이거나 
	  함수 정의 앞에 inline이라는 키워드를 붙인다.
	- 클래스 멤버 함수가 inline을 사용하려면, 함수 정의의 위치가 *.h에 있어야 한다. 
	  안 그러면 확인할 수 없는 외부 참조라고 뜬다.
	- 프로그래머가 inline 선언을 해도 컴파일러가 인라인화를 거부할 수 있다.
	- 프로그래머가 inline 선언을 안 해도 컴파일러가 인라인화를 할 수 있다.
	- 함수의 덩치가 크거나 재귀호출이면 inline 요구를 거절하는 컴파일러도 있다.
	- 함수 코드의 수행 시간이 짧고 빈번하게 호출되는 함수가 아니라면, 
	  인라인 함수로 인한 절대적인 시간 절약은 그다지 크지 않다.

	(장점)
	- 함수가 인라인화 되어 성능의 향상으로 이어질 수 있다.

	(단점)
	- 메모리 사용 측면에서는 인라인 함수가 일반 함수보다 불리하다. 
	  이유는 어떤 프로그램에서 인라인 함수를 열 번 호출한다면, 
	  프로그램은 그 함수의 사본을 프로그램의 코드 안에 열 번이나 삽입해야 하기 때문이다.
	- 매크로 함수와 달리 자료형에 독립적이지 못 하다. 
	  단, 템플릿을 이용하면 자료형에 독립적으로 사용할 수 있다.
*/
int main()
{


	return 0;
}