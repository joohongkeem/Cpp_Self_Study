#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
using namespace std;


/*
	- 프렌드 함수는 멤버 함수가 아니지만 멤버 함수의 특권을 모두 가지고 있다.
	> 프렌드 함수에 대해 논하기 전에 생성자를 통한 자동 형 변환에 대하여 논의한다.
	> 이것은 우리에게 프렌드 함수로서 연산자 오버로딩하는 것에 대한 장점을 설명해준다.


	* 자동 형 변환에 대한 생성자

	- 만약 클래스 정의에 적절한 생성자가 포함된다면, 시스템은 형 변환을 자동으로 수행한다.
		Ex) Money baseAmount(100,60), fullAmount;
			fullAmount = baseAmount+25;
			fullAmount.output();
			을 하게 되면, $125.60이 출력이 된다.
				
			   ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
			-> 연산자 오버로딩을 멤버함수로 하면 이렇게 출력되지 않고, (_022_Overloading(MemberFunction).cpp 참고)
			   연산자 오버로딩을 클래스 외부에 함수로 선언하면 잘 출력된다. (_021_Overloading(Basic).cpp 참고) 
	  
	  But, 곰곰히 생각해보면 무엇인가 이상하다!
	       식에서 25는 적절한 형이 아니다! 왜냐면, 1개의 정수와 Money형에 대하여 덧셈을 오버로딩 하지 않았기 때문!!
		   즉, 클래스의 정의부에서 정수형을 Money형으로 변환하는 방법을 알려주지 않는 한,
		       25는 Money형으로 사용될 수 없다.
		   이 때, 어떠한 과정을 거치냐면, 
		       첫번째로, 시스템은 Money형과 정수형의 조합으로 연산자가 오버로딩 되었는지 체크한다. -> 없음
			   두번째로, 시스템은 정수형의 하나의 인자를가지는 생성자가 있는지 검사한다. -> 있음
						  이러한 생성자가 있으니, 이 생성자를 사용하여 정수 25를 Money형으로 변환시킨다.
			   만약, 두번째에 해당하는 생성자가 없다면, 형 변환이 일어나지 않음을 명심하자! ★★★★★★★★

	> 생성자에 의해 자동으로 일어나는 자동 형 변환은 +나 -같은 숫자 연산자 오버로딩에서는 일반적으로 행해진다.
	  하지만, 이러한 자동 형 변환은 일반적인 함수, 멤버 함수, 그리고 오버로딩된 함수의 인자에 같은 방법으로 적용됨!


	* [★함정★] 멤버 연산자와 자동 형 변환
  
	- 이항 연산자를 멤버 연산자로서 오버로딩 할때, 2개의 인자는 더이상 대칭적이지 않다.
	> 하나는 호출 객체이고, 나머지 하나는 인자이다. (여기서 멤버연산자로 오버로딩할때 치명적인 단점이 드러난다!!★★)
	> 어떠한 자동 형 변환도 두번째 인자에만 적용이 되기 때문에,
			fullAmount = 25 + baseAmount; 를 하게되면, 25는 객체를 호출하지 못하기 떄문에, baseAmount와의 덧셈이 불가능해진다.
	> But, 이항 연산자를 클래스 외부에서 오버로딩하면, 완벽하게 동일하게 작동한다

	★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
	- 즉 정리하자면,
		연산자를 독립적으로 오버로딩할 경우의 
			장점 : fullAmount = 25 + baseAmount; fullAmout = baseAmout + 25; 모두 가능
			단점 : private 멤버 변수에 직접 접근할 수 없어, mutator, accessor 함수를 사용해야 한다.
		연산자를 멤버함수로 오버로딩할 경우의
			장점 : private 멤버 변수에 직접 접근할 수 있어, mutator, accessor 함수를 사용할 필요가 없다.
			단점 : fullAmout = baseAmout + 25; 의 값도 이상하게 출력되며,
			        fullAmount = 25 + baseAmount; 는 실행조차 되지 않는다.

		-> 이와 같은 두 가지 장점을 모두 가지는 방법이 '프렌드 함수로서 오버로딩' 하는 방법이다.
*/


/*
	* 프렌드 함수

*/